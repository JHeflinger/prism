#version 450

layout(set = 0, binding = 0) uniform UniformBufferObject {
	vec3 look;
	vec3 position;
	vec3 up;
    vec3 u;
    vec3 v;
    vec3 w;
    vec3 camconf;
    vec3 sizes;
    vec2 viewport;
} ubo;

struct RayGenerator {
    uint x;
    uint y;
};

struct Triangle {
    vec3 a;
    vec3 b;
    vec3 c;
};

layout(set = 0, binding = 1) readonly buffer RayGeneratorSSBOIn {
   RayGenerator raygenIn[ ];
};

layout(set = 0, binding = 2, rgba8) uniform image2D outputImage;

layout(set = 0, binding = 3) readonly buffer TriangleSSBOIn {
    Triangle triangleIn[ ];
};

layout (local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

void main() 
{
	// get ray generator
    uint index= gl_GlobalInvocationID.x;
    RayGenerator rgIn = raygenIn[index];

    // unpack camera conf for readability
    float fov = ubo.camconf.x;
    float width = ubo.camconf.y;
    float height = ubo.camconf.z;

    // reject any rays outside of the viewport
    if (ubo.viewport.x != 0 && 
        (rgIn.x < ceil(((width - ubo.viewport.x) / 2.0)) ||
        (rgIn.x > ceil(((width + ubo.viewport.x) / 2.0))))) return;
    if (ubo.viewport.y != 0 && 
        (rgIn.y < ceil(((height - ubo.viewport.y) / 2.0)) ||
        (rgIn.y > ceil(((height + ubo.viewport.y) / 2.0))))) return;

	// create ray
	float r = width / 2.0;
	float b = height / 2.0;
	float l = -1.0 * r;
	float t = -1.0 * b;
    float u = l + ((r - l) * (float(rgIn.x) + 0.5)) / width;
    float v = b + ((t - b) * (float(rgIn.y) + 0.5)) / height;
	float d = (cos(fov / 2.0) / sin(fov / 2.0)) * r;
    vec3 ray_direction = normalize((ubo.u * u) + (ubo.v * v) - (ubo.w * d));
    vec3 ray_position = ubo.position;

    // number of triangles
    uint num_triangles = uint(ubo.sizes.x);

    // triangle intersections
    float distance = -1.0;
    for (uint i = 0; i < num_triangles; i++) {
        Triangle tri = triangleIn[i];
        vec3 tri_normal = normalize(cross(tri.b - tri.a, tri.c - tri.b));
        float hit_distance = dot(tri.a - ray_position, tri_normal) / dot(ray_direction, tri_normal);
        if (hit_distance > 0) {
            vec3 hit_at = ray_position + (ray_direction * hit_distance);
            if (dot(cross(tri.b - tri.a, hit_at - tri.a), tri_normal) > 0 &&
                dot(cross(tri.c - tri.b, hit_at - tri.b), tri_normal) > 0 &&
                dot(cross(tri.a - tri.c, hit_at - tri.c), tri_normal) > 0) {
                if (distance == -1.0) {
                    distance = hit_distance;
                } else if (hit_distance < distance) {
                    distance = hit_distance;
                }
            }
        }
    }

	// color in pixel
    ivec2 pixel = ivec2(rgIn.x, rgIn.y);
    vec4 color = vec4(normalize(abs(ray_direction)), 1.0);
    if (distance > 0) {
        float tval = 1.0 - (distance / (2.0f * length(ubo.position)));
        color = vec4(tval, tval, tval, 1.0);
    }
    imageStore(outputImage, pixel, color);
}
