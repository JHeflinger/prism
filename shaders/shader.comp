#version 450

#define MAX_RECURSIVE_DEPTH 2000
#define MAX_BOUNCES 1
#define EPS 0.0001

layout(set = 0, binding = 0) uniform UniformBufferObject {
	vec3 look;
	vec3 position;
	vec3 up;
    vec3 u;
    vec3 v;
    vec3 w;
    float fov;
    float width;
    float height;
    uint triangles;
    vec2 viewport;
    uint bvhsize;
	float frametime;
	float frameless;
	uint seed;
} ubo;

struct RayGenerator {
    uint x;
    uint y;
	float time;
};

struct Triangle {
    vec3 a;
    vec3 b;
    vec3 c;
    uint material;
};

struct Material {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float reflection;
    float refraction;
    float rindex;
    float transparency;
    float shiny;
    float glossy;
};

struct NodeBVH {
    vec3 min;
    vec3 max;
    uint config;
    uint left;
    uint right;
};

layout(set = 0, binding = 1) buffer RayGeneratorSSBOIn {
   RayGenerator raygenIn[ ];
};

layout(set = 0, binding = 2, rgba8) uniform image2D outputImage;

layout(set = 0, binding = 3) readonly buffer TriangleSSBOIn {
    Triangle triangleIn[ ];
};

layout(set = 0, binding = 4) readonly buffer MaterialSSBOIn {
    Material materialIn[ ];
};

layout(set = 0, binding = 5) readonly buffer BVHSSBOIn {
    NodeBVH bvhIn[ ];
};

layout (local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

RayGenerator rgIn;
vec3 ray_direction;
vec3 ray_position;
vec3 color;

float hit_distance = -1.0;
uint hit_material = 0;
vec3 hit_normal = vec3(0, 0, 0);
vec3 hit_position;
bool stack_failure = false;

vec3 light_position = vec3(1.0, 1.0, 0.5);
vec3 ambient_light = vec3(1.0, 0.5, 0.0);
vec3 diffuse_light = vec3(1.0, 1.0, 1.0);
vec3 specular_light = vec3(1.0, 1.0, 1.0);
float light_distance;
vec3 light_direction;

float random(float n) {
	return fract(sin(n) * 43758.5453123);
}

void cut_viewport() {
    if (ubo.viewport.x != 0 &&
        (rgIn.x < ceil(((ubo.width - ubo.viewport.x) / 2.0)) ||
        (rgIn.x > ceil(((ubo.width + ubo.viewport.x) / 2.0))))) return;
    if (ubo.viewport.y != 0 &&
        (rgIn.y < ceil(((ubo.height - ubo.viewport.y) / 2.0)) ||
        (rgIn.y > ceil(((ubo.height + ubo.viewport.y) / 2.0))))) return;
}

void create_ray() {
	float r = ubo.width / 2.0;
	float b = ubo.height / 2.0;
	float l = -1.0 * r;
	float t = -1.0 * b;
    float u = l + ((r - l) * (float(rgIn.x) + 0.5)) / ubo.width;
    float v = b + ((t - b) * (float(rgIn.y) + 0.5)) / ubo.height;
	float d = (cos(ubo.fov / 2.0) / sin(ubo.fov / 2.0)) * r;
    ray_direction = normalize((ubo.u * u) + (ubo.v * v) - (ubo.w * d));
    ray_position = ubo.position;
}

bool intersect_triangle(uint triangle_ind, inout vec3 tri_normal, inout float distance, inout uint material) {
    Triangle tri = triangleIn[triangle_ind];
    tri_normal = normalize(cross(tri.b - tri.a, tri.c - tri.b));
    distance = dot(tri.a - ray_position, tri_normal) / dot(ray_direction, tri_normal);
    if (distance > 0) {
        vec3 hit_at = ray_position + (ray_direction * distance);
        if (dot(cross(tri.b - tri.a, hit_at - tri.a), tri_normal) > 0 &&
            dot(cross(tri.c - tri.b, hit_at - tri.b), tri_normal) > 0 &&
            dot(cross(tri.a - tri.c, hit_at - tri.c), tri_normal) > 0) {
            material = tri.material;
            return true;
        }
    }
    return false;
}

bool aabb_intersect(uint node_ind) {
    float entrance = 0.0;
    float exit = 3.402823466e+38;
    for (int i = 0; i < 3; i++) {
        float slab_a = bvhIn[node_ind].min[i];
        float slab_b = bvhIn[node_ind].max[i];
        float inv_dir = 1.0 / ray_direction[i];
        float origin = ray_position[i];
        float closest = (slab_a - origin) * inv_dir;
        float farthest = (slab_b - origin) * inv_dir;
        if (farthest < closest) {
            float temp = farthest;
            farthest = closest;
            closest = temp;
        }
        if (farthest < entrance || closest > exit) return false;
        exit = farthest < exit ? farthest : exit;
        entrance = closest > entrance ? closest : entrance;
    }
    return true;
}

void naiive_intersect_ray() {
    for (uint i = 0; i < ubo.triangles; i++) {
        vec3 tri_normal;
        float distance;
        uint material;
        if (intersect_triangle(i, tri_normal, distance, material)) {
            if (hit_distance == -1.0) {
                hit_distance = distance;
                hit_material = material;
                hit_normal = tri_normal;
            } else if (distance < hit_distance) {
                hit_distance = distance;
                hit_material = material;
                hit_normal = tri_normal;
            }
        }
    }
    hit_position = ubo.position + (ray_direction * hit_distance);
    light_direction = normalize(hit_position - light_position) * -1.0;
    light_distance = length(hit_position - light_position);
}

void accelerated_intersect_ray() {
    if (ubo.bvhsize == 0) return;
    if (!aabb_intersect(0)) return;
    vec3 tri_normal;
    float new_distance;
    uint material;
    uint stack[MAX_RECURSIVE_DEPTH];
    int stack_ptr = 0;
    stack[stack_ptr++] = 0;
    while (stack_ptr > 0) {
        NodeBVH node = bvhIn[stack[--stack_ptr]];
        if (stack_ptr >= MAX_RECURSIVE_DEPTH - 1) { stack_failure = true; break; }
        if (node.config == 0) {
            if (intersect_triangle(node.left, tri_normal, new_distance, material)) {
                if (hit_distance == -1.0) {
                    hit_distance = new_distance;
                    hit_material = material;
                    hit_normal = tri_normal;
                } else if (new_distance < hit_distance) {
                    hit_distance = new_distance;
                    hit_material = material;
                    hit_normal = tri_normal;
                }
            }
        } else if (node.config == 1) {
            if (aabb_intersect(node.left))
                stack[stack_ptr++] = node.left;
        } else if (node.config == 2) {
            if (aabb_intersect(node.right))
                stack[stack_ptr++] = node.right;
        } else {
            if (aabb_intersect(node.left))
                stack[stack_ptr++] = node.left;
            if (aabb_intersect(node.right))
                stack[stack_ptr++] = node.right;
        }
    }
}

void draw_point_light() {
    float light_radius = 1.0;
    vec3 l_t = ray_position + (dot(light_position - ray_position, ray_direction) *  ray_direction);
    float l_d = length(l_t - light_position);
    vec3 light_color = (ambient_light + diffuse_light + specular_light) / 3.0;
    if (l_t != ray_position &&
        (length(l_t - ray_position) < hit_distance ||
            hit_distance <= 0) && 
        l_d < light_radius) {
        float brilliance = 1.0 - (l_d / light_radius);
        color = mix(color, light_color, pow(brilliance, 5));
    }
}

bool find_shadows() {
    if (hit_distance < 0.0) return false;
    vec3 temp_ray_direction = ray_direction;
    vec3 temp_ray_position = ray_position;
    float temp_hit_distance = hit_distance;
    uint temp_hit_material = hit_material;
    vec3 temp_hit_normal = hit_normal;
    vec3 temp_hit_position = hit_position;
    hit_distance = -1.0;

    ray_position = light_position;
    ray_direction = light_direction * -1.0;

    bool is_shadowed = false;
    if (dot(hit_normal, light_direction) < 0.0) {
        return true;
    } else {
        accelerated_intersect_ray();
        is_shadowed = hit_distance > 0.0 && hit_distance < light_distance - EPS;
    }
    
    ray_direction = temp_ray_direction;
    ray_position = temp_ray_position;
    hit_distance = temp_hit_distance;
    hit_material = temp_hit_material;
    hit_normal = temp_hit_normal;
    return is_shadowed;
}

vec3 shade_color() {
    vec3 shadedcolor = abs(ray_direction) / 1.0;
    if (hit_distance > 0) {
        // shadows
        bool is_shadowed = find_shadows();

        // material
        Material material = materialIn[hit_material];

        // ambient light
        shadedcolor = material.ambient * ambient_light;

        // diffuse light
        if (!is_shadowed)
            shadedcolor += material.diffuse * diffuse_light * dot(light_direction, hit_normal);

        // specular light
        vec3 reflection = normalize(reflect(light_direction, hit_normal));
        float specular_const = dot(reflection, ray_direction);
        if (specular_const >= 0 && !is_shadowed)
            shadedcolor += specular_light * material.specular * pow(specular_const, material.shiny);

        // divide to ensure not above 1, 1, 1
        shadedcolor /= 3.0;
    }
    return shadedcolor;
}

void reflect_color(int bounces) {
    vec3 temp_ray_direction = ray_direction;
    vec3 temp_ray_position = ray_position;
    float temp_hit_distance = hit_distance;
    uint temp_hit_material = hit_material;
    vec3 temp_hit_normal = hit_normal;
    vec3 temp_hit_position = hit_position;
    vec3 temp_light_direction = light_direction;
    float temp_light_distance = light_distance;
    if (hit_distance >= 0.0) {
        Material material = materialIn[hit_material];
        if (material.reflection > 0.0) {
            vec3 colors[MAX_BOUNCES];
            float reflectionvals[MAX_BOUNCES];
            int num_colors = 0;
            for (int i = 0; i < bounces; i++) {
                hit_distance = -1.0;
                ray_direction = reflect(ray_direction, hit_normal);
                ray_position = hit_position + (ray_direction * EPS);
                accelerated_intersect_ray();
                hit_position = ubo.position + (ray_direction * hit_distance);
                light_direction = normalize(hit_position - light_position) * -1.0;
                light_distance = length(hit_position - light_position);
                reflectionvals[num_colors] = material.reflection;
                colors[num_colors++] = shade_color();
                if (hit_distance <= 0.0 || materialIn[hit_material].reflection <= 0.0) break;
                material = materialIn[hit_material];
            }
            for (int i = num_colors - 1; i >= 0; i--) {
                if (i == 0) {
                    color = mix(color, colors[i], reflectionvals[i]);
                } else {
                    colors[i - 1] = mix(colors[i - 1], colors[i], reflectionvals[i]);
                }
            }
        }
    }
    light_distance = temp_light_distance;
    light_direction = temp_light_direction;
    ray_direction = temp_ray_direction;
    ray_position = temp_ray_position;
    hit_distance = temp_hit_distance;
    hit_material = temp_hit_material;
    hit_normal = temp_hit_normal;
    // if hit

    // get material

    // if material is reflective

    // for # bounces
        // new ray

        // intersect new ray

        // color new ray

        // add that color to the current color

        // if new ray is reflective continue
        // otherwise break
}

void main() {
	// update ray history
	raygenIn[gl_GlobalInvocationID.x].time += ubo.frametime;

	// get ray generator
    rgIn = raygenIn[gl_GlobalInvocationID.x];

	// calculate frame chance
	float chance = 1.0 - pow(1.0 - ubo.frameless, rgIn.time);
	if (random((rgIn.x * rgIn.y) / 123.456789) > chance) return;

	// clear ray history
	raygenIn[gl_GlobalInvocationID.x].time = 0.0;

	// reject any rays outside of the viewport
    cut_viewport();

	// create ray
    create_ray();

    // intersect ray
    accelerated_intersect_ray();

    // setup more light data
    hit_position = ubo.position + (ray_direction * hit_distance);
    light_direction = normalize(hit_position - light_position) * -1.0;
    light_distance = length(hit_position - light_position);

	// color in pixel
    color = shade_color();

    // reflect
    reflect_color(MAX_BOUNCES);

    // draw point light
    draw_point_light();

    // stack failure
    if (stack_failure) color = vec3(1.0, 0.0, 0.0);

    // write to image
	if (ubo.frameless < 1.0) {
		vec4 prev_color = imageLoad(outputImage, ivec2(rgIn.x, rgIn.y));
		color = mix(color, prev_color.xyz, 0.5);
	}
    imageStore(outputImage, ivec2(rgIn.x, rgIn.y), vec4(color, 1.0));
}
