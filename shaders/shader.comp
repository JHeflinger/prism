#version 450

#define MAX_RECURSIVE_DEPTH 2000
#define MAX_BOUNCES 1
#define EPS 0.0001

layout(set = 0, binding = 0) uniform UniformBufferObject {
	vec3 look;
	vec3 position;
	vec3 up;
    vec3 u;
    vec3 v;
    vec3 w;
    float fov;
    float width;
    float height;
    uint triangles;
    vec2 viewport;
    uint bvhsize;
	float frametime;
	float frameless;
	uint seed;
	uint shadows;
	uint reflections;
	uint lighting;
    uint raytrace;
    uint sdf;
    uint sdfsize;
} ubo;

struct RayGenerator {
    uint x;
    uint y;
	float time;
};

struct Ray {
    vec3 position;
    vec3 direction;
};

struct Hit {
    float distance;
    uint material;
    vec3 normal;
    vec3 position;
};

struct Triangle {
    vec3 a;
    vec3 b;
    vec3 c;
    uint material;
};

struct Material {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float reflection;
    float refraction;
    float rindex;
    float transparency;
    float shiny;
    float glossy;
};

struct PointLight {
    vec3 position;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float distance;
    vec3 direction;
};

struct NodeBVH {
    vec3 min;
    vec3 max;
    uint config;
    uint left;
    uint right;
};

struct SDFPrimitive {
    uint type;
    vec3 origin;
    float scale;
};

layout(set = 0, binding = 1) buffer RayGeneratorSSBOIn {
   RayGenerator raygenIn[ ];
};

layout(set = 0, binding = 2, rgba8) uniform image2D outputImage;

layout(set = 0, binding = 3) readonly buffer TriangleSSBOIn {
    Triangle triangleIn[ ];
};

layout(set = 0, binding = 4) readonly buffer MaterialSSBOIn {
    Material materialIn[ ];
};

layout(set = 0, binding = 5) readonly buffer BVHSSBOIn {
    NodeBVH bvhIn[ ];
};

layout(set = 0, binding = 6) readonly buffer SDFSSBOIn {
    SDFPrimitive sdfIn[ ];
};

layout (local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

bool stack_failure = false;

float random(float n) {
	return fract(sin(n) * 43758.5453123);
}

bool cut_viewport(RayGenerator rg) {
    if (ubo.viewport.x != 0 &&
        (rg.x < ceil(((ubo.width - ubo.viewport.x) / 2.0)) ||
        (rg.x > ceil(((ubo.width + ubo.viewport.x) / 2.0))))) return true;
    if (ubo.viewport.y != 0 &&
        (rg.y < ceil(((ubo.height - ubo.viewport.y) / 2.0)) ||
        (rg.y > ceil(((ubo.height + ubo.viewport.y) / 2.0))))) return true;
    return false;
}

Ray create_ray(RayGenerator rg) {
	float r = ubo.width / 2.0;
	float b = ubo.height / 2.0;
	float l = -1.0 * r;
	float t = -1.0 * b;
    float u = l + ((r - l) * (float(rg.x) + 0.5)) / ubo.width;
    float v = b + ((t - b) * (float(rg.y) + 0.5)) / ubo.height;
	float d = (cos(ubo.fov / 2.0) / sin(ubo.fov / 2.0)) * r;
    Ray ray;
    ray.direction = normalize((ubo.u * u) + (ubo.v * v) - (ubo.w * d));
    ray.position = ubo.position;
    return ray;
}

bool triangle_intersect(Ray ray, uint triangle_ind, inout Hit hit) {
    Triangle tri = triangleIn[triangle_ind];
    hit.normal = normalize(cross(tri.b - tri.a, tri.c - tri.b));
    hit.distance = dot(tri.a - ray.position, hit.normal) / dot(ray.direction, hit.normal);
    if (hit.distance > 0) {
        vec3 hit_at = ray.position + (ray.direction * hit.distance);
        if (dot(cross(tri.b - tri.a, hit_at - tri.a), hit.normal) > 0 &&
            dot(cross(tri.c - tri.b, hit_at - tri.b), hit.normal) > 0 &&
            dot(cross(tri.a - tri.c, hit_at - tri.c), hit.normal) > 0) {
            hit.material = tri.material;
            hit.position = ray.position + (ray.direction * hit.distance);
            return true;
        }
    }
    return false;
}

bool aabb_intersect(Ray ray, uint node_ind) {
    float entrance = 0.0;
    float exit = 3.402823466e+38;
    for (int i = 0; i < 3; i++) {
        float slab_a = bvhIn[node_ind].min[i];
        float slab_b = bvhIn[node_ind].max[i];
        float inv_dir = 1.0 / ray.direction[i];
        float origin = ray.position[i];
        float closest = (slab_a - origin) * inv_dir;
        float farthest = (slab_b - origin) * inv_dir;
        if (farthest < closest) {
            float temp = farthest;
            farthest = closest;
            closest = temp;
        }
        if (farthest < entrance || closest > exit) return false;
        exit = farthest < exit ? farthest : exit;
        entrance = closest > entrance ? closest : entrance;
    }
    return true;
}

Hit raytrace(Ray ray) {
    Hit hit;
    hit.distance = -1.0;
    if (ubo.bvhsize == 0) return hit;
    if (!aabb_intersect(ray, 0)) return hit;
    uint stack[MAX_RECURSIVE_DEPTH];
    int stack_ptr = 0;
    stack[stack_ptr++] = 0;
    while (stack_ptr > 0) {
        NodeBVH node = bvhIn[stack[--stack_ptr]];
        if (stack_ptr >= MAX_RECURSIVE_DEPTH - 1) { stack_failure = true; break; }
        if (node.config == 0) {
            Hit trihit;
            if (triangle_intersect(ray, node.left, trihit)) {
                if (hit.distance == -1.0 || trihit.distance < hit.distance) {
                    hit = trihit;
                }
            }
        } else if (node.config == 1) {
            if (aabb_intersect(ray, node.left))
                stack[stack_ptr++] = node.left;
        } else if (node.config == 2) {
            if (aabb_intersect(ray, node.right))
                stack[stack_ptr++] = node.right;
        } else {
            if (aabb_intersect(ray, node.left))
                stack[stack_ptr++] = node.left;
            if (aabb_intersect(ray, node.right))
                stack[stack_ptr++] = node.right;
        }
    }
    return hit;
}

bool is_shadowed(Hit hit, PointLight light) {
    if (hit.distance < 0.0 || ubo.shadows == 0) return false;
    if (dot(hit.normal, light.direction) < 0.0) return true;
    bool shadowed = false;
    Ray ray;
    ray.position = light.position;
    ray.direction = light.direction * -1.0;
    Hit shit = raytrace(ray);
    shadowed = shit.distance > 0.0 && shit.distance < light.distance - EPS;
    return shadowed;
}

vec3 shade(Ray ray, Hit hit, PointLight light) {
	if (ubo.lighting == 0 && hit.distance > 0) {
        float dif = clamp( dot(hit.normal,vec3(0.7,0.6,0.4)), 0.0, 1.0 );
        float amb = 0.5 + 0.5*dot(hit.normal,vec3(0.0,0.8,0.6));
        return sqrt(vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif);
	}
    vec3 color;
    if (hit.distance > 0) {
        // shadows
        bool shadowed = is_shadowed(hit, light);

        // material
        Material material = materialIn[hit.material];

        // ambient light
        color = material.ambient * light.ambient;

        // diffuse light
        if (!shadowed)
            color += material.diffuse * light.diffuse * dot(light.direction, hit.normal);

        // specular light
        vec3 reflection = normalize(reflect(light.direction, hit.normal));
        float specular_const = dot(reflection, ray.direction);
        if (specular_const >= 0 && !shadowed)
            color += light.specular * material.specular * pow(specular_const, material.shiny);

        // divide to ensure not above 1, 1, 1
        color /= 3.0;
    }
    return color;
}

PointLight default_light(Hit hit) {
    PointLight light;
    light.position = vec3(1.0, 1.0, 1.5);
    light.ambient = vec3(1.0, 1.0, 1.0);
    light.diffuse = vec3(1.0, 1.0, 1.0);
    light.specular = vec3(1.0, 1.0, 1.0);
    light.direction = normalize(hit.position - light.position) * -1.0;
    light.distance = length(hit.position - light.position);
    return light;
}

void raymarch() {

}

void draw_light(Ray ray, Hit hit, PointLight light, inout vec3 color) {
    float light_radius = 1.0;
    vec3 l_t = ray.position + (dot(light.position - ray.position, ray.direction) * ray.direction);
    float l_d = length(l_t - light.position);
    vec3 light_color = (light.ambient + light.diffuse + light.specular) / 3.0;
    if (l_t != ray.position &&
        (hit.distance <= 0 || length(l_t - ray.position) < hit.distance) && 
        l_d < light_radius) {
        float brilliance = 1.0 - (l_d / light_radius);
        color = mix(color, light_color, pow(brilliance, 5));
    }
}

void reflect_color(Ray ray, Hit hit, int bounces, inout vec3 color) {
	if (ubo.reflections == 0) return;
    if (hit.distance >= 0.0) {
        Material material = materialIn[hit.material];
        if (material.reflection > 0.0) {
            vec3 colors[MAX_BOUNCES];
            float reflectionvals[MAX_BOUNCES];
            int num_colors = 0;
            Hit rhit = hit;
            Ray rray = ray;
            for (int i = 0; i < bounces; i++) {
                rray.direction = reflect(rray.direction, rhit.normal);
                rray.position = rhit.position + (rray.direction * EPS);
                rhit = raytrace(rray);
                rhit.position = ubo.position + (rray.direction * rhit.distance); // should we keep this in? should this be using ubo.position...
                PointLight light = default_light(rhit);
                reflectionvals[num_colors] = material.reflection;
                colors[num_colors++] = shade(ray, rhit, light);
                if (rhit.distance <= 0.0 || materialIn[rhit.material].reflection <= 0.0) break;
                material = materialIn[rhit.material];
            }
            for (int i = num_colors - 1; i >= 0; i--) {
                if (i == 0) {
                    color = mix(color, colors[i], reflectionvals[i]);
                } else {
                    colors[i - 1] = mix(colors[i - 1], colors[i], reflectionvals[i]);
                }
            }
        }
    }
}

void main() {
	// update ray history
	raygenIn[gl_GlobalInvocationID.x].time += ubo.frametime;

	// get ray generator
    RayGenerator rgIn = raygenIn[gl_GlobalInvocationID.x];

	// calculate frame chance
	float chance = 1.0 - pow(1.0 - ubo.frameless, rgIn.time);
	if (random((rgIn.x * rgIn.y) / 123.456789) > chance) return;

	// clear ray history
	raygenIn[gl_GlobalInvocationID.x].time = 0.0;

	// reject any rays outside of the viewport
    if (cut_viewport(rgIn)) return;

	// create ray
    Ray ray = create_ray(rgIn);

    // colors
    vec3 color = abs(ray.direction) / 1.0;

    // trace/march
    Hit hit;
    hit.distance = -1.0;
    PointLight light = default_light(hit);
    if (ubo.raytrace != 0) {
        hit = raytrace(ray);
        if (hit.distance > 0.0) {
            light = default_light(hit);
            color = shade(ray, hit, light);
            reflect_color(ray, hit, MAX_BOUNCES, color);
        }
    } else if (ubo.sdf != 0) {
        // raymarch to get distance
        raymarch();
    }
    draw_light(ray, hit, light, color);

    // stack failure
    if (stack_failure) color = vec3(1.0, 0.0, 0.0);

    // write to image
	if (ubo.frameless < 1.0) {
		vec4 prev_color = imageLoad(outputImage, ivec2(rgIn.x, rgIn.y));
		color = mix(color, prev_color.xyz, 0.5);
	}
    imageStore(outputImage, ivec2(rgIn.x, rgIn.y), vec4(color, 1.0));
}
